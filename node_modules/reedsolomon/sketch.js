#!node

var rs = require('reedsolomon');

var Interleaver = function () { this.init.apply(this, arguments) };
Interleaver.prototype = {
	init : function (messageSize, partSize) {
		this.buffer = new Int32Array(messageSize);
		this.count = partSize;
		this.windowSize = messageSize / partSize;
	},

	// just transpose
	interleave : function (message) {
		message = message.subarray(0, this.buffer.length);
		var buffer = this.buffer, window = this.windowSize;
		for (var i = 0; i < window; i++) {
			for (var j = 0; j < this.count; j++) {
				buffer[i * this.count + j] = message[j * window + i];
			}
		}
		message.set(buffer);
	},

	deinterleave : function (message) {
		message = message.subarray(0, this.buffer.length);
		var buffer = this.buffer, window = this.windowSize;
		for (var i = 0; i < window; i++) {
			for (var j = 0; j < this.count; j++) {
				buffer[j * window + i] = message[i * this.count + j];
			}
		}
		message.set(buffer);
	}
};

var MessageCodec = function () { this.init.apply(this, arguments) };
MessageCodec.prototype = {
	/**
	 * FRAME_SIZE = FRAME_DATA_SIZE + FRAME_ERROR_CORRECTION
	 * L1 = RAW_DATA_SIZE + PAYLOAD_ERROR_CORRECTION
	 * PAYLOAD_SIZE = L1 + (PART_COUNT * FRAME_ERROR_CORRECTION)
	 * FRAME_DATA_SIZE = L1 / PART_COUNT
	 *
	 * Level1
	 * | RAW_DATA | EC |
	 *       ->
	 * |  interleaved  |
	 *
	 * Level2
	 * | interleaved / n | EC | * n
	 */

	init : function (opts) {
		if (!opts) opts = {};

		var self = this;
		self.PART_COUNT = 8;
		self.PAYLOAD_SIZE = 256;
		self.PAYLOAD_ERROR_CORRECTION = 64;
		self.PAYLOAD_DATA_SIZE = self.PAYLOAD_SIZE - self.PAYLOAD_ERROR_CORRECTION;
		self.FRAME_SIZE = self.PAYLOAD_SIZE / self.PART_COUNT;
		self.FRAME_ERROR_CORRECTION = 8;
		self.FRAME_DATA_SIZE = self.FRAME_SIZE - self.FRAME_ERROR_CORRECTION;
		self.RAW_DATA_SIZE = self.FRAME_DATA_SIZE * self.PART_COUNT - self.PAYLOAD_ERROR_CORRECTION;
		self.DEBUG = opts.DEBUG;

		self.message  = new Int32Array(self.PAYLOAD_SIZE);
		self.interleaver = new Interleaver(self.RAW_DATA_SIZE + self.PAYLOAD_ERROR_CORRECTION, self.PART_COUNT);
		self.encoder = new rs.ReedSolomonEncoder(rs.GenericGF.AZTEC_DATA_8());
		self.decoder = new rs.ReedSolomonDecoder(rs.GenericGF.AZTEC_DATA_8());

		if (self.DEBUG) {
			console.log('FRAME_SIZE', self.FRAME_SIZE);
			console.log('FRAME_ERROR_CORRECTION', self.FRAME_ERROR_CORRECTION);
			console.log('FRAME_DATA_SIZE', self.FRAME_DATA_SIZE);
			console.log('PAYLOAD_SIZE', self.PAYLOAD_SIZE);
			console.log('PAYLOAD_ERROR_CORRECTION', self.PAYLOAD_ERROR_CORRECTION);
			console.log('PAYLOAD_DATA_SIZE', self.PAYLOAD_DATA_SIZE);
			console.log('PART_COUNT', self.PART_COUNT);

			console.log('RAW_DATA_SIZE', self.RAW_DATA_SIZE);
			console.log('Transfer effciency', self.RAW_DATA_SIZE / self.PAYLOAD_SIZE);
		}
	},

	encode : function (raw, callback) {
		var self = this;
		var count = Math.ceil(raw.length / self.RAW_DATA_SIZE);
		for (var i = 0; i < count; i++) {
			var start = i * self.RAW_DATA_SIZE;
			var end   = Math.min(raw.length, start + self.RAW_DATA_SIZE);
			for (var j = 0; j < (end - (start + self.RAW_DATA_SIZE)); j++) {
				self.message[j] = 0;
			}
			self.message.set(raw.subarray(start, end));
			self._encode();
			callback(self.message);
		}
	},

	_encode : function () {
		var self = this;
		var message = self.message;

		self.dump('raw data', message);

		self.encoder.encode(message.subarray(0, self.RAW_DATA_SIZE + self.PAYLOAD_ERROR_CORRECTION), self.PAYLOAD_ERROR_CORRECTION);

		self.dump('rs coded', message);

		self.interleaver.interleave(message);

		self.dump('interleaved', message);

		for (var i = self.PART_COUNT - 1; i >= 0; i--) {
			var dst = message.subarray(i * self.FRAME_SIZE, (i + 1) * self.FRAME_SIZE);
			var src = message.subarray(i * self.FRAME_DATA_SIZE, (i + 1) * self.FRAME_DATA_SIZE);
			dst.set(src);
			self.encoder.encode(dst, self.FRAME_ERROR_CORRECTION);
		}

		self.dump('rs coded 2', message);
	},

	decode : function (raw, callback) {
		var self = this;
		self.message.set(raw.subarray(0, self.message.length));
		self._decode();
		callback(self.message);
	},

	_decode : function () {
		var self = this;
		var message = self.message;

		for (var i = 0; i < self.PART_COUNT; i++) {
			var dst = message.subarray(i * self.FRAME_DATA_SIZE, (i + 1) * self.FRAME_DATA_SIZE);
			var src = message.subarray(i * self.FRAME_SIZE, (i + 1) * self.FRAME_SIZE);
			try {
				decoder.decode(src, self.FRAME_ERROR_CORRECTION);
			} catch (e) {
			}
			dst.set(src.subarray(0, dst.length));
		}

		self.dump('rs decoded 2', message);

		self.interleaver.deinterleave(message);

		self.dump('deinterleaved', message);

		self.decoder.decode(message.subarray(0, self.RAW_DATA_SIZE + self.PAYLOAD_ERROR_CORRECTION), self.PAYLOAD_ERROR_CORRECTION);

		self.dump('rs decoded', message.subarray(0, self.RAW_DATA_SIZE));
	},

	dump : function (message, typedarray) {
		if (!this.DEBUG) return;
		console.log(message);
		console.log(Array.prototype.join.call(typedarray));
		console.log('');
	}
};

var codec = new MessageCodec();
var message = new Int32Array(256);
for (var i = 0; i < 256; i++) {
	message[i] = i;
}

codec.encode(message, function (encoded) {
	console.log(encoded.length);
});

//var PART_COUNT = 8;
//var PAYLOAD_SIZE = 256;
//var PAYLOAD_ERROR_CORRECTION = 64;
//var PAYLOAD_DATA_SIZE = PAYLOAD_SIZE - PAYLOAD_ERROR_CORRECTION;
//var FRAME_SIZE = PAYLOAD_SIZE / PART_COUNT;
//var FRAME_ERROR_CORRECTION = 8;
//var FRAME_DATA_SIZE = FRAME_SIZE - FRAME_ERROR_CORRECTION;
//
//var RAW_DATA_SIZE = FRAME_DATA_SIZE * PART_COUNT - PAYLOAD_ERROR_CORRECTION;
//
//console.log('FRAME_SIZE', FRAME_SIZE);
//console.log('FRAME_ERROR_CORRECTION', FRAME_ERROR_CORRECTION);
//console.log('FRAME_DATA_SIZE', FRAME_DATA_SIZE);
//console.log('PAYLOAD_SIZE', PAYLOAD_SIZE);
//console.log('PAYLOAD_ERROR_CORRECTION', PAYLOAD_ERROR_CORRECTION);
//console.log('PAYLOAD_DATA_SIZE', PAYLOAD_DATA_SIZE);
//console.log('PART_COUNT', PART_COUNT);
//
//console.log('RAW_DATA_SIZE', RAW_DATA_SIZE);
//console.log('Transfer effciency', RAW_DATA_SIZE / PAYLOAD_SIZE);
//
//var message  = new Int32Array(PAYLOAD_SIZE);
//var interleaver = new Interleaver(RAW_DATA_SIZE + PAYLOAD_ERROR_CORRECTION, PART_COUNT);
//
//var encoder = new rs.ReedSolomonEncoder(rs.GenericGF.AZTEC_DATA_8());
//console.log(encoder.field.toString());
//
//for (var i = 0; i < RAW_DATA_SIZE; i++) {
//	message[i] = i;
//}
//
//console.log('raw data');
//console.log(Array.prototype.join.call(message));
//console.log('');
//
//encoder.encode(message.subarray(0, RAW_DATA_SIZE + PAYLOAD_ERROR_CORRECTION), PAYLOAD_ERROR_CORRECTION);
//
//console.log('RS coded');
//console.log(Array.prototype.join.call(message));
//console.log('');
//
//interleaver.interleave(message);
//console.log('interleave');
//console.log(Array.prototype.join.call(message));
//console.log('');
//
//for (var i = PART_COUNT - 1; i >= 0; i--) {
//	var dst = message.subarray(i * FRAME_SIZE, (i + 1) * FRAME_SIZE);
//	var src = message.subarray(i * FRAME_DATA_SIZE, (i + 1) * FRAME_DATA_SIZE);
//	dst.set(src);
//	encoder.encode(dst, FRAME_ERROR_CORRECTION);
////	console.log(dst.length, '=', FRAME_SIZE);
////	console.log(Array.prototype.join.call(dst));
////	console.log(Array.prototype.join.call(src));
//}
//
//console.log('RS coded 2');
//console.log(Array.prototype.join.call(message));
//console.log('');
//
//
//
//console.log('corrupt');
//for (var i = 0; i < 30; i++) {
//	message[i+10] = 0xff;
//}
//for (var i = 0; i < 10; i++) {
//	message[Math.floor(Math.random() * RAW_DATA_SIZE)] = 0;
//}
//console.log(Array.prototype.join.call(message));
//console.log('');
//
//var decoder = new rs.ReedSolomonDecoder(rs.GenericGF.AZTEC_DATA_8());
//for (var i = 0; i < PART_COUNT; i++) {
//	var dst = message.subarray(i * FRAME_DATA_SIZE, (i + 1) * FRAME_DATA_SIZE);
//	var src = message.subarray(i * FRAME_SIZE, (i + 1) * FRAME_SIZE);
//	try {
//		decoder.decode(src, FRAME_ERROR_CORRECTION);
//	} catch (e) {
//	}
//	dst.set(src.subarray(0, dst.length));
//}
//
//console.log('RS decoded 2');
//console.log(Array.prototype.join.call(message));
//console.log('');
//
//
//console.log('deinterleave');
//interleaver.deinterleave(message);
//console.log(Array.prototype.join.call(message));
//console.log('');
//
//decoder.decode(message.subarray(0, RAW_DATA_SIZE + PAYLOAD_ERROR_CORRECTION), PAYLOAD_ERROR_CORRECTION);
//
//console.log('RS decoded 1');
//console.log(Array.prototype.join.call(message.subarray(0, RAW_DATA_SIZE)));
